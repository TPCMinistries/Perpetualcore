import { NextRequest } from "next/server";
import pptxgen from "pptxgenjs";
import { jsPDF } from "jspdf";
import ExcelJS from "exceljs";
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } from "docx";

// POST /api/generate-document - Generate PowerPoint, PDF, or Excel documents
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const { type, title, content, slides, data } = body;

    if (!type || !["powerpoint", "pdf", "excel", "word"].includes(type)) {
      return new Response(
        JSON.stringify({ error: "Invalid document type. Must be 'powerpoint', 'pdf', 'excel', or 'word'" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    let buffer: Buffer;
    let filename: string;
    let mimeType: string;

    switch (type) {
      case "powerpoint":
        ({ buffer, filename, mimeType } = await generatePowerPoint(title, slides || content));
        break;
      case "pdf":
        ({ buffer, filename, mimeType } = await generatePDF(title, content));
        break;
      case "excel":
        ({ buffer, filename, mimeType } = await generateExcel(title, data || content));
        break;
      case "word":
        ({ buffer, filename, mimeType } = await generateWord(title, content));
        break;
      default:
        return new Response(
          JSON.stringify({ error: "Unsupported document type" }),
          { status: 400, headers: { "Content-Type": "application/json" } }
        );
    }

    return new Response(buffer, {
      headers: {
        "Content-Type": mimeType,
        "Content-Disposition": `attachment; filename="${filename}"`,
      },
    });
  } catch (error: any) {
    console.error("Error generating document:", error);
    return new Response(
      JSON.stringify({ error: error.message || "Failed to generate document" }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
}

async function generatePowerPoint(title: string, slides: any[]) {
  const pptx = new pptxgen();

  // Title slide
  const titleSlide = pptx.addSlide();
  titleSlide.background = { color: "1F4788" };
  titleSlide.addText(title || "Presentation", {
    x: 0.5,
    y: 2.5,
    w: 9,
    h: 1.5,
    fontSize: 44,
    bold: true,
    color: "FFFFFF",
    align: "center",
  });
  titleSlide.addText("Generated by AI", {
    x: 0.5,
    y: 4.0,
    w: 9,
    h: 0.5,
    fontSize: 18,
    color: "CCCCCC",
    align: "center",
  });

  // Content slides
  if (Array.isArray(slides)) {
    slides.forEach((slideData) => {
      const slide = pptx.addSlide();
      slide.background = { color: "FFFFFF" };

      // Slide title
      if (slideData.title) {
        slide.addText(slideData.title, {
          x: 0.5,
          y: 0.5,
          w: 9,
          h: 0.75,
          fontSize: 32,
          bold: true,
          color: "1F4788",
        });
      }

      // Slide content
      if (slideData.content) {
        const contentLines = Array.isArray(slideData.content)
          ? slideData.content
          : slideData.content.split("\n");

        slide.addText(contentLines.join("\n"), {
          x: 0.5,
          y: 1.5,
          w: 9,
          h: 4,
          fontSize: 18,
          color: "333333",
          valign: "top",
        });
      }
    });
  } else if (typeof slides === "string") {
    // If slides is a string, create slides from paragraphs
    const paragraphs = slides.split("\n\n").filter((p) => p.trim());
    paragraphs.forEach((para, index) => {
      const slide = pptx.addSlide();
      slide.background = { color: "FFFFFF" };

      slide.addText(`Slide ${index + 1}`, {
        x: 0.5,
        y: 0.5,
        w: 9,
        h: 0.75,
        fontSize: 32,
        bold: true,
        color: "1F4788",
      });

      slide.addText(para, {
        x: 0.5,
        y: 1.5,
        w: 9,
        h: 4,
        fontSize: 18,
        color: "333333",
        valign: "top",
      });
    });
  }

  const buffer = await pptx.write({ outputType: "nodebuffer" }) as Buffer;

  return {
    buffer,
    filename: `${title?.replace(/[^a-z0-9]/gi, "_") || "presentation"}.pptx`,
    mimeType: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  };
}

async function generatePDF(title: string, content: string) {
  const doc = new jsPDF();

  // Title
  doc.setFontSize(24);
  doc.setFont(undefined, "bold");
  doc.text(title || "Document", 20, 20);

  // Date
  doc.setFontSize(10);
  doc.setFont(undefined, "normal");
  doc.text(`Generated: ${new Date().toLocaleDateString()}`, 20, 30);

  // Content
  doc.setFontSize(12);
  const splitContent = doc.splitTextToSize(content || "", 170);
  doc.text(splitContent, 20, 45);

  const buffer = Buffer.from(doc.output("arraybuffer"));

  return {
    buffer,
    filename: `${title?.replace(/[^a-z0-9]/gi, "_") || "document"}.pdf`,
    mimeType: "application/pdf",
  };
}

async function generateExcel(title: string, data: any) {
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet(title || "Sheet1");

  // If data is an array of objects, treat as table
  if (Array.isArray(data) && data.length > 0 && typeof data[0] === "object") {
    const headers = Object.keys(data[0]);

    // Add header row
    worksheet.addRow(headers);
    const headerRow = worksheet.getRow(1);
    headerRow.font = { bold: true };
    headerRow.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "FF1F4788" },
    };
    headerRow.font = { color: { argb: "FFFFFFFF" }, bold: true };

    // Add data rows
    data.forEach((row) => {
      worksheet.addRow(headers.map((h) => row[h]));
    });

    // Auto-fit columns
    worksheet.columns.forEach((column) => {
      let maxLength = 0;
      column.eachCell?.({ includeEmpty: true }, (cell) => {
        const columnLength = cell.value ? cell.value.toString().length : 10;
        if (columnLength > maxLength) {
          maxLength = columnLength;
        }
      });
      column.width = maxLength < 10 ? 10 : maxLength + 2;
    });
  } else if (typeof data === "string") {
    // If data is a string, split into rows
    const rows = data.split("\n").map((row) => row.split("\t"));
    rows.forEach((row) => worksheet.addRow(row));
  } else {
    // Default: create a simple sheet with the content
    worksheet.addRow([title || "Data"]);
    worksheet.addRow([data?.toString() || ""]);
  }

  const buffer = await workbook.xlsx.writeBuffer();

  return {
    buffer: Buffer.from(buffer),
    filename: `${title?.replace(/[^a-z0-9]/gi, "_") || "spreadsheet"}.xlsx`,
    mimeType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  };
}

async function generateWord(title: string, content: string) {
  // Split content into paragraphs
  const paragraphs = content?.split("\n").filter((p) => p.trim()) || [];

  const doc = new Document({
    sections: [{
      properties: {},
      children: [
        // Title
        new Paragraph({
          text: title || "Document",
          heading: HeadingLevel.HEADING_1,
          spacing: {
            after: 400,
          },
        }),
        // Date
        new Paragraph({
          children: [
            new TextRun({
              text: `Generated: ${new Date().toLocaleDateString()}`,
              italics: true,
              size: 20,
            }),
          ],
          spacing: {
            after: 400,
          },
        }),
        // Content paragraphs
        ...paragraphs.map((para) =>
          new Paragraph({
            children: [
              new TextRun({
                text: para,
                size: 24,
              }),
            ],
            spacing: {
              after: 200,
            },
          })
        ),
      ],
    }],
  });

  const buffer = await Packer.toBuffer(doc);

  return {
    buffer: Buffer.from(buffer),
    filename: `${title?.replace(/[^a-z0-9]/gi, "_") || "document"}.docx`,
    mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  };
}
